x_wrist_right <- jsd$people[[1]]$hand_right_keypoints_2d[1]
y_wrist_right <- jsd$people[[1]]$hand_right_keypoints_2d[2]
#get index points, keypoint 8
#left hand
x_index_left <- jsd$people[[1]]$hand_left_keypoints_2d[22]
y_index_left <- jsd$people[[1]]$hand_left_keypoints_2d[23]
#right hand
x_index_right <- jsd$people[[1]]$hand_right_keypoints_2d[22]
y_index_right <- jsd$people[[1]]$hand_right_keypoints_2d[23]
#append frame info to dataframe
frameMT <- cbind.data.frame(x_nose, y_nose,conf_nose,
x_wrist_left, y_wrist_left, conf_wrist_left,
x_wrist_right, y_wrist_right, conf_wrist_right,
x_index_left, y_index_left, conf_index_left,
x_index_right, y_index_right, conf_index_right)
MT <- rbind.data.frame(MT, frameMT)
}
#post apply
MT$y_wrist_left  <- MT$y_wrist_left*-1                  #mirror y as y-axis is flipped (higher position = lower y)
MT$y_index_left  <- MT$y_index_left*-1                  #mirror y as y-axis is flipped (higher position = lower y)
MT$y_wrist_right  <- MT$y_wrist_right*-1                #mirror y as y-axis is flipped (higher position = lower y)
MT$y_index_right  <- MT$y_index_right*-1                #mirror y as y-axis is flipped (higher position = lower y)
#smooth, center, and scale all kinematics
MT <- apply(MT, 2, smooth) #smooth each time series column with 33hz filter
MT <- apply(MT, 2, scale) #normalize and center
#save in time series output folder
tsfilename <- str_extract(vidfold, "[^_]+")
write.csv(MT, paste0(timeserfolder, tsfilename, ".csv"))
}
MT <- read.csv(paste0(timeserfolder, "TO-SWIM.csv"))
MT$frames <- 1:nrow(MT)
a <- ggplot(MT, aes(x = frames)) +
geom_path(aes(y = x_index_right), color = "red") +
geom_path(aes(y = x_index_left), color = "blue") + theme_bw()+ylab("position normalized")
ggplotly(a)
timeseriess <- list.files(timeserfolder)
timeseriess
* Create and save a time series for each video with relevant kinematics and smooth with a type of moving average filter (kolmogorov golai filter, span 5, degree 3)
timeseriess <- list.files(timeserfolder)
timeseriess
timeseriess
MT
files <- list.files(openposfolder) #collect motion tracking items to process
####FUNCTIONS
#set smoothing function zero-lag butterworth filter 30 Hz
#check out smoothing
smooth <- function(x)
{
output <- kza::kz(x, 5, k = 3) #zero phase filter using filtfilt
}
#####MAIN PROCEDURE
#loop, collect, smooth, and save kinematic data
for(vidfold in files)
{
jsfileloc <- paste0(openposfolder, vidfold, "/")    #location json files
list_json <- list.files(  jsfileloc, pattern = ".json")      #index all json files
MT <- data.frame()                                           #initialize a motion tracking data frame
#loop over the json frame files
for(frame in list_json)
{
#load jsd$pose_keypoints_2d
jsd <- fromJSON(file = paste0(  jsfileloc, frame))         #load in frame
#get nose points, keypoint 0
x_nose <- jsd$people[[1]]$pose_keypoints_2d[1]
y_nose <- jsd$people[[1]]$pose_keypoints_2d[2]
#get hand wrist points, keypoint 0
#left hand
x_wrist_left <- jsd$people[[1]]$hand_left_keypoints_2d[1]
y_wrist_left <- jsd$people[[1]]$hand_left_keypoints_2d[2]
#right hand
x_wrist_right <- jsd$people[[1]]$hand_right_keypoints_2d[1]
y_wrist_right <- jsd$people[[1]]$hand_right_keypoints_2d[2]
#get index points, keypoint 8
#left hand
x_index_left <- jsd$people[[1]]$hand_left_keypoints_2d[22]
y_index_left <- jsd$people[[1]]$hand_left_keypoints_2d[23]
#right hand
x_index_right <- jsd$people[[1]]$hand_right_keypoints_2d[22]
y_index_right <- jsd$people[[1]]$hand_right_keypoints_2d[23]
#append frame info to dataframe
frameMT <- cbind.data.frame(x_nose, y_nose,
x_wrist_left, y_wrist_left,
x_wrist_right, y_wrist_right,
x_index_left, y_index_left,
x_index_right, y_index_right)
MT <- rbind.data.frame(MT, frameMT)
}
#post apply
MT$y_wrist_left  <- MT$y_wrist_left*-1                  #mirror y as y-axis is flipped (higher position = lower y)
MT$y_index_left  <- MT$y_index_left*-1                  #mirror y as y-axis is flipped (higher position = lower y)
MT$y_wrist_right  <- MT$y_wrist_right*-1                #mirror y as y-axis is flipped (higher position = lower y)
MT$y_index_right  <- MT$y_index_right*-1                #mirror y as y-axis is flipped (higher position = lower y)
#smooth, center, and scale all kinematics
MT <- apply(MT, 2, smooth) #smooth each time series column with 33hz filter
MT <- apply(MT, 2, scale) #normalize and center
#save in time series output folder
tsfilename <- str_extract(vidfold, "[^_]+")
write.csv(MT, paste0(timeserfolder, tsfilename, ".csv"))
}
MT
colnames(MT)
colnames(MT[,5:6])
#dtw forward backward
forwardbackward.dtw <- function(x)
{ output <- dtw(z, y, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance +
dtw(y, z, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance}
#Summed DTW
DTW.compare <- function(TS1, TS2)
{
#perform the dynamic time warping backwards and forwards, extract the distance, and then average
distancedtw <-  mean(forwardbackward.dtw(TS1[1:2], TS2[1:2]),
forwardbackward.dtw(TS1[3:4], TS2[3:4]),
forwardbackward.dtw(TS1[5:6], TS2[5:6]),
forwardbackward.dtw(TS1[7:8], TS2[7:8]),
forwardbackward.dtw(TS1[9:10], TS2[9:10]))
return(distancedtw)
}
numges <- length(timeseriess)
numges
numges <- length(timeseriess)
distmat <- matrix(nrow=numges, ncol=numges)
distmat
timeseriess
timeseriess
ts2
ts1 <- timeseriess[1]
catchname <- c(catchname, substr(ts1,1,nchar(ts1)-4)) #save the gesture ID
substr(ts1,1,nchar(ts1)-4)
n <- 0
n =+1
n
timeseriess
which(timeseriess == ts1)
distmat[which(timeseriess == ts1),which(timeseriess == ts2)] <- DTW.compare(TS1, TS2)
TS1
distmat <- matrix(nrow=numges, ncol=numges) <- NA
distmat
is.na(distmat[TS2index,TS1index])
timeseriess <- list.files(timeserfolder)
#########################FUNCTIONS
#dtw forward backward
forwardbackward.dtw <- function(x)
{ output <- dtw(z, y, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance +
dtw(y, z, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance}
#Summed DTW
DTW.compare <- function(TS1, TS2)
{
#perform the dynamic time warping backwards and forwards, extract the distance, and then average
distancedtw <-  mean(forwardbackward.dtw(TS1[1:2], TS2[1:2]),
forwardbackward.dtw(TS1[3:4], TS2[3:4]),
forwardbackward.dtw(TS1[5:6], TS2[5:6]),
forwardbackward.dtw(TS1[7:8], TS2[7:8]),
forwardbackward.dtw(TS1[9:10], TS2[9:10]))
return(distancedtw)
}
#########################MAIN ROUTINE
#initialize some variables
numges <- length(timeseriess)
distmat <- matrix(nrow=numges, ncol=numges)
catchnames <- vector()
n <- 0
#loop through all combination and save
for(ts1 in timeseriess)
{
TS1 <- read.csv(paste0(timeserfolder, ts1))
TS1index <- which(timeseriess == ts1) #index of this gesture
catchnames <- c(catchnames, substr(ts1,1,nchar(ts1)-4)) #save the gesture ID
for(ts2 in timeseriess)
{
TS2index <- which(timeseriess == ts2) #index of this gesture
if(is.na(distmat[TS2index,TS1index])) #pass only if calculation has not been done
{
TS2 <- read.csv(paste0(timeserfolder, ts2))
#compute DTW and save into matrix
dtwoutput <- DTW.compare(TS1, TS2)
distmat[TS1index,TS2index] <- dtwoutput
distmat[TS2index,TS1index] <- dtwoutput #its a symmetrical result
}
}
}
colname(distmat) <- catchnames
#dtw forward backward
forwardbackward.dtw <- function(x)
{ output <- dtw(z, y, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance +
dtw(y, z, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance}
#Summed DTW
DTW.compare <- function(TS1, TS2)
{
#perform the dynamic time warping backwards and forwards, extract the distance, and then average
distancedtw <-  mean(forwardbackward.dtw(TS1[1:2], TS2[1:2]),
forwardbackward.dtw(TS1[3:4], TS2[3:4]),
forwardbackward.dtw(TS1[5:6], TS2[5:6]),
forwardbackward.dtw(TS1[7:8], TS2[7:8]),
forwardbackward.dtw(TS1[9:10], TS2[9:10]))
return(distancedtw)
}
#initialize some variables
numges <- length(timeseriess)
distmat <- matrix(nrow=numges, ncol=numges)
catchnames <- vector()
n <- 0
#loop through all combination and save
for(ts1 in timeseriess)
{
TS1 <- read.csv(paste0(timeserfolder, ts1))
TS1index <- which(timeseriess == ts1) #index of this gesture
catchnames <- c(catchnames, substr(ts1,1,nchar(ts1)-4)) #save the gesture ID
for(ts2 in timeseriess)
{
TS2index <- which(timeseriess == ts2) #index of this gesture
if(is.na(distmat[TS2index,TS1index])) #pass only if calculation has not been done
{
TS2 <- read.csv(paste0(timeserfolder, ts2))
#compute DTW and save into matrix
dtwoutput <- DTW.compare(TS1, TS2)
distmat[TS1index,TS2index] <- dtwoutput
distmat[TS2index,TS1index] <- dtwoutput #its a symmetrical result
}
}
}
colnames(distmat) <- catchnames
catchnames
TS2index <- which(timeseriess == ts2) #index of this gesture
TS2index
TS2 <- read.csv(paste0(timeserfolder, ts2))
TS2
dtwoutput <- DTW.compare(TS1, TS2)
TS2
#dtw forward backward
forwardbackward.dtw <- function(x,y)
{ output <- dtw(x, y, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance +
dtw(x, y, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance}
#Summed DTW
DTW.compare <- function(TS1, TS2)
{
#perform the dynamic time warping backwards and forwards, extract the distance, and then average
distancedtw <-  mean(forwardbackward.dtw(TS1[1:2], TS2[1:2]),
forwardbackward.dtw(TS1[3:4], TS2[3:4]),
forwardbackward.dtw(TS1[5:6], TS2[5:6]),
forwardbackward.dtw(TS1[7:8], TS2[7:8]),
forwardbackward.dtw(TS1[9:10], TS2[9:10]))
return(distancedtw)
}
#initialize some variables
numges <- length(timeseriess)
distmat <- matrix(nrow=numges, ncol=numges)
catchnames <- vector()
n <- 0
#loop through all combination and save
for(ts1 in timeseriess)
{
TS1 <- read.csv(paste0(timeserfolder, ts1))
TS1index <- which(timeseriess == ts1) #index of this gesture
catchnames <- c(catchnames, substr(ts1,1,nchar(ts1)-4)) #save the gesture ID
for(ts2 in timeseriess)
{
TS2index <- which(timeseriess == ts2) #index of this gesture
if(is.na(distmat[TS2index,TS1index])) #pass only if calculation has not been done
{
TS2 <- read.csv(paste0(timeserfolder, ts2))
#compute DTW and save into matrix
dtwoutput <- DTW.compare(TS1, TS2)
distmat[TS1index,TS2index] <- dtwoutput
distmat[TS2index,TS1index] <- dtwoutput #its a symmetrical result
}
}
}
colnames(distmat) <- catchnames
distmat
distancematfolder <- paste0(basefolder, "/Distance_matrices/")
distmat
write.csv(paste0(distancematfolder, "distance_matrix_v1.csv"))
write.csv(distmat,paste0(distancematfolder, "distance_matrix_v1.csv"))
write.csv(distmat,paste0(distancematfolder, "distance_matrix_v1.csv"), row.names = FALSE)
timeseriess <- list.files(timeserfolder)
#########################FUNCTIONS
#dtw forward backward with free begin-and-end constraints
forwardbackward.dtw <- function(x,y)
{ output <- mean(dtw(x, y, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance +
dtw(y, x, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance)}
#Summed DTW
DTW.compare <- function(TS1, TS2)
{
#perform the dynamic time warping backwards and forwards, extract the distance, and then average
distancedtw <-  mean(forwardbackward.dtw(TS1[1:2], TS2[1:2]),
forwardbackward.dtw(TS1[3:4], TS2[3:4]),
forwardbackward.dtw(TS1[5:6], TS2[5:6]),
forwardbackward.dtw(TS1[7:8], TS2[7:8]),
forwardbackward.dtw(TS1[9:10], TS2[9:10]))
return(distancedtw)
}
#########################MAIN ROUTINE
#initialize some variables
numges <- length(timeseriess) #how many gestures (should be 110)
distmat <- matrix(nrow=numges, ncol=numges)  #110x110 matrix
catchnames <- vector() #get the names so that we know what columns/rows belong to which ID
n <- 0
#loop through all combinations and save DTW score
for(ts1 in timeseriess)
{
TS1 <- read.csv(paste0(timeserfolder, ts1))
TS1index <- which(timeseriess == ts1) #index of this gesture
catchnames <- c(catchnames, substr(ts1,1,nchar(ts1)-4)) #save the gesture ID
for(ts2 in timeseriess)
{
TS2index <- which(timeseriess == ts2) #index of this gesture
if(is.na(distmat[TS2index,TS1index])) #pass only if calculation has not been done
{
TS2 <- read.csv(paste0(timeserfolder, ts2))
#compute DTW and save into matrix
dtwoutput <- DTW.compare(TS1, TS2)
distmat[TS1index,TS2index] <- dtwoutput
distmat[TS2index,TS1index] <- dtwoutput #its a symmetrical result
}
}
}
colnames(distmat) <- catchnames
#save distance matrix
write.csv(distmat,paste0(distancematfolder, "distance_matrix_v1.csv"), row.names = FALSE)
iconicityratings <- read.csv(basefolder, "/IconicityRatings/Iconicity_ratings.csv")
basefolder
iconicityratings <- read.csv(basefolder, "/IconicityRatings/Iconicity_ratings.csv")
workingdrive <- getwd()
basefolder   <- dirname(workingdrive)
openposfolder <- paste0(basefolder, "/Motion_tracking_openpose/")
timeserfolder <- paste0(basefolder, "/Time_series/")
distancematfolder <- paste0(basefolder, "/Distance_matrices/")
iconicityratings <- read.csv(basefolder, "/IconicityRatings/Iconicity_ratings.csv")
basefolder
iconicityratings <- read.csv(paste0(basefolder, "/IconicityRatings/Iconicity_ratings.csv"))
iconicityratings
avdist <- colmeans(distmat)
avdist <- colMeans(distmat)
avdist
names <- colnames(distmat)
names
kininfo <- cbind.data.frame(avdist, names)
kininfo
icki <- merge(kininfo, iconicityratings, by.x = "names", by.y = "English")
icki
ggplot(icki, aes(x=avdist, y = MEAN)) + geom_point()
a <- ggplot(icki, aes(x=avdist, y = MEAN, color = Mode.of.rep)) + geom_point()
a
a <- ggplot(icki, aes(x=avdist, y = MEAN, color = Mode.of.rep)) + geom_point() +
geom_smooth() + theme_bw()
a
a <- ggplot(icki, aes(x=avdist, y = MEAN, color = Mode.of.rep)) + geom_point()
a
a <- ggplot(icki, aes(x=avdist, y = MEAN, color = Mode.of.rep)) + geom_point()
a
iconicityratings
a <- ggplot(icki, aes(x=avdist, y = MEAN, color = Mode.of.rep)) + facet_grid(mode.of.rep~.)
a
a <- ggplot(icki, aes(x=avdist, y = MEAN, color = Mode.of.rep)) + facet_grid(Mode.of.rep~.)
a
a <- ggplot(icki, aes(x=avdist, y = MEAN, color = Mode.of.rep))
a
distmat
avdist <- colMeans(distmat)
names <- colnames(distmat)
kininfo <- cbind.data.frame(avdist, names)
icki <- merge(kininfo, iconicityratings, by.x = "names", by.y = "English")
a <- ggplot(icki, aes(x=avdist, y = MEAN, color = Mode.of.rep))
a
distmat
icki
#packages
library(kza)        #for kolmogorov golai filter
library(dtw)         #for dynamic time warping
library(rjson)       #for extracting json info
library(stringr)     #for manipulations of strings
library(ggplot2)     #plotting
library(plotly)     #plotting
#set current as working drive via session -> set working drive -> source file location
workingdrive <- getwd()
basefolder   <- dirname(workingdrive)
openposfolder <- paste0(basefolder, "/Motion_tracking_openpose/")
timeserfolder <- paste0(basefolder, "/Time_series/")
distancematfolder <- paste0(basefolder, "/Distance_matrices/")
iconicityratings <- read.csv(paste0(basefolder, "/IconicityRatings/Iconicity_ratings.csv"))
timeseriess <- list.files(timeserfolder)
#########################FUNCTIONS
#dtw forward backward with free begin-and-end constraints
forwardbackward.dtw <- function(x,y)
{ output <- mean(dtw(x, y, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance +
dtw(y, x, open.end = TRUE, open.begin = TRUE, step.pattern=asymmetric)$normalizedDistance)}
#dtw alligned over the whole segment
symmetric.dtw <- function(TS1,TS2)
{
mean(dtw(TS1[1:2], TS2[1:2])$normalizedDistance,
dtw(TS1[3:4], TS2[3:4])$normalizedDistance,
dtw(TS1[5:6], TS2[5:6])$normalizedDistance,
dtw(TS1[7:8], TS2[7:8])$normalizedDistance,
dtw(TS1[9:10], TS2[9:10])$normalizedDistance)
}
#Summed DTW
DTW.compare <- function(TS1, TS2)
{
#perform the dynamic time warping backwards and forwards, extract the distance, and then average
distancedtw <-  mean(forwardbackward.dtw(TS1[1:2], TS2[1:2]),
forwardbackward.dtw(TS1[3:4], TS2[3:4]),
forwardbackward.dtw(TS1[5:6], TS2[5:6]),
forwardbackward.dtw(TS1[7:8], TS2[7:8]),
forwardbackward.dtw(TS1[9:10], TS2[9:10]))
return(distancedtw)
}
#########################MAIN ROUTINE
#initialize some variables
numges <- length(timeseriess) #how many gestures (should be 110)
distmat <- matrix(nrow=numges, ncol=numges)  #110x110 matrix
distmat2 <- matrix(nrow=numges, ncol=numges)  #110x110 matrix
catchnames <- vector() #get the names so that we know what columns/rows belong to which ID
n <- 0
#loop through all combinations and save DTW score
for(ts1 in timeseriess)
{
TS1 <- read.csv(paste0(timeserfolder, ts1)) #read first time series
TS1index <- which(timeseriess == ts1) #index of this gesture
catchnames <- c(catchnames, substr(ts1,1,nchar(ts1)-4)) #save the gesture ID
for(ts2 in timeseriess)
{
TS2index <- which(timeseriess == ts2) #index of this gesture
if(is.na(distmat[TS2index,TS1index])) #pass only if calculation has not been done
{
TS2 <- read.csv(paste0(timeserfolder, ts2)) #read second time series
#compute DTW and save into matrix
dtwoutput <- DTW.compare(TS1, TS2)
dtw2outpout <- symmetric.dtw(TS1, TS2)
distmat[TS1index,TS2index] <- dtwoutput
distmat[TS2index,TS1index] <- dtwoutput #its a symmetrical result so fill two cells
distmat2[TS1index,TS2index] <- dtw2outpout
distmat2[TS2index,TS1index] <- dtw2outpout
}
}
}
colnames(distmat) <- catchnames #attach the names to the distance matrix
#save distance matrix
write.csv(distmat,paste0(distancematfolder, "distance_matrix_freeconstraints_v1.csv"), row.names = FALSE)
write.csv(distmat2,paste0(distancematfolder, "distance_matrix_dtw_v1.csv"), row.names = FALSE)
histogram(distmat)
hist(distmat)
hist(log(distmat))
hist(log(distmat+1))
write.csv(log(distmat+1),paste0(distancematfolder, "distance_matrix_v2.csv"), row.names = FALSE)
colnames(distmat) <- catchnames #attach the names to the distance matrix
#the distmat has a long tailed distribution with extreme variation, therefore do a log transform
distmat2 <- log(distmat+1)
colnames(distmat2) <- catchnames #attach the names to the distance matrix 2
distmatlog
#the distmat has a long tailed distribution with extreme variation, therefore do a log transform
hit(distmat)
distmat2 <- log(distmat+1)
colnames(distmatlog) <- catchnames #attach the names to the distance matrix 2
hist(distmatlog)
hit(distmat)
distmatlog <- log(distmat+1)
colnames(distmatlog) <- catchnames #attach the names to the distance matrix 2
hist(distmatlog)
distmatlog
diag(distmatlog)
distmatlog <- 1/distmatlog #make distances into weights
dismatlog
distmatlog
distmatlog[is.infinite(distmatlog)] <- 0
distmatlog
distmatlog[is.infinite(distmatlog)]
is.infinite(distmatlog)
is.finite(distmatlog)
View(distmatlog)
distmatlog
#the distmat has a long tailed distribution with extreme variation, therefore do a log transform
hit(distmat)
distmatlog <- log(distmat+1)
colnames(distmatlog) <- catchnames #attach the names to the distance matrix 2
hist(distmatlog)
#the distmat has a long tailed distribution with extreme variation, therefore do a log transform
hist(distmat)
distmatlog <- log(distmat+1)
colnames(distmatlog) <- catchnames #attach the names to the distance matrix 2
hist(distmatlog)
distmatlog <- 1/distmatlog #make distances into weights
distmatlog[is.infinite(distmatlog)] <- 0
distmatlog
#the distmat has a long tailed distribution with extreme variation, therefore do a log transform
hist(distmat)
distmatlog <- log(distmat+1)
colnames(distmatlog) <- catchnames #attach the names to the distance matrix 2
hist(distmatlog)
distmatlognet <- graph_from_adjacency_matrix(distmatlog, mode = c("undirected"), weighted = TRUE,
diag = FALSE, add.colnames = catchnames)
library(igraph)
distmatlognet <- graph_from_adjacency_matrix(distmatlog, mode = c("undirected"), weighted = TRUE,
diag = FALSE, add.colnames = catchnames)
distmatlog
distmatlognet <- graph_from_adjacency_matrix(distmatlog, mode = c("undirected"), weighted = TRUE,
diag = FALSE)
distmatlognet
shortest.paths(distmatlognet, v=igraph.vs.all(graph), mode = "all")
shortest.paths(distmatlognet, v=igraph.vs.all(distmatlognet), mode = "all")
shortest.paths(distmatlognet, v=distmatlognet, mode = "all")
distmatlognet <- graph_from_adjacency_matrix(distmatlog, mode = c("undirected"), weighted = TRUE,
diag = FALSE)
distmatlognet
shortest.paths(distmatlognet, mode = "all")
write.csv(distmatlog,paste0(distancematfolder, "dist_mat_shortestpath_v2.csv"), row.names = FALSE)
write.csv(shortestpath,paste0(distancematfolder, "dist_mat_shortestpath_v2.csv"), row.names = FALSE)
shortestpath <- shortest.paths(distmatlognet, mode = "all")
write.csv(shortestpath,paste0(distancematfolder, "dist_mat_shortestpath_v2.csv"), row.names = FALSE)
hist(shortestpath)
shortestpath==distmatlog
isSymmetric(shotestpath)
isSymmetric(shortestpath)
